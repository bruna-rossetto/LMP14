# -*- coding: utf-8 -*-
"""codigoBOT

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IuE_yd3hVyUp68ntiIc9r0TtGeLiQ6D4
"""

from google.colab import drive
import os
drive.mount('/content/drive')

pasta_imagens = '/content/drive/MyDrive/Projeto visão computacional - PET-MA/Imagens 31-10'

arquivos_imagens = [f for f in os.listdir(pasta_imagens) if f.endswith('.tif')]

imagens_processadas = []

import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab import drive
from google.colab.patches import cv2_imshow

for nome_arquivo in arquivos_imagens:
  caminho = os.path.join(pasta_imagens, nome_arquivo)

  imagem = cv2.imread(caminho, cv2.IMREAD_GRAYSCALE)
  cropped_image = imagem[100:1300, 300:1500]

  img_blur = cv2.blur(src=cropped_image, ksize=(9,9))
  src = cv2.bilateralFilter(src=img_blur, d=11, sigmaColor=100, sigmaSpace=50)

#cv2_imshow(imagem)
#cv2_imshow(src)

  imagens_processadas.append((nome_arquivo, cropped_image, src))

import numpy as np
import matplotlib.pyplot as plt

valores_thresh_para_testar = range(60, 81, 2)

num_valores = len(valores_thresh_para_testar)
cols = 4
rows = int(np.ceil(num_valores / cols))

for nome_arquivo, cropped_image, src in imagens_processadas:
  print(f"{nome_arquivo}")
  plt.figure(figsize=(15, 4 * rows))
  plt.suptitle('Teste de Diferentes Valores de Limiar (Threshold)', fontsize=16)

  for i, thresh_valor in enumerate(valores_thresh_para_testar):
    th, dst = cv2.threshold(src, thresh_valor, 255, cv2.THRESH_BINARY_INV)

        # Adiciona a imagem resultante na nossa grade de visualização
    plt.subplot(rows, cols, i + 1)
    plt.imshow(dst, cmap='gray')
    plt.title(f'Thresh = {thresh_valor}') # Adiciona o valor como título
    plt.axis('off') # Remove os eixos

  plt.tight_layout(rect=[0, 0, 1, 0.96]) # Ajusta o layout para o título principal não sobrepor
  plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow

for nome_arquivo, cropped_image, src in imagens_processadas:
   print(f"{nome_arquivo}")

   adapt_thresh = cv2.adaptiveThreshold(src,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY_INV,blockSize=31,C=4)
   kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (9,9))
   clean = cv2.morphologyEx(adapt_thresh, cv2.MORPH_CLOSE, kernel, iterations=12)
   invertido = cv2.bitwise_not(clean)

   contornos, _ = cv2.findContours(invertido, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
   resultado = cv2.cvtColor(cropped_image, cv2.COLOR_GRAY2BGR)

   if len(contornos) > 0:
    altura, largura = cropped_image.shape
    centro_imagem_x = largura // 2
    centro_imagem_y = altura // 2

    contorno_central = None
    min_distancia_ao_centro = float('inf')

    for c in contornos:
      M = cv2.moments(c)
      if M["m00"] > 0:
        cX = int(M["m10"] / M["m00"])
        cY = int(M["m01"] / M["m00"])
      else:
        continue

      distancia = np.sqrt((cX - centro_imagem_x)**2 + (cY - centro_imagem_y)**2)
      if distancia < min_distancia_ao_centro:
        min_distancia_ao_centro = distancia
        contorno_central = c

    cv2.drawContours(resultado, [contorno_central], -1, (0, 255, 0), 2)
    area_contorno = cv2.contourArea(contorno_central)
    perimetro_contorno = cv2.arcLength(contorno_central, True)
    circularidade_real = (4 * np.pi * area_contorno) / (perimetro_contorno ** 2)

    print("\n--- MEDIÇÕES (Baseadas no Contorno Central) ---")
    print(f"Área do Contorno Real (com rebarbas): {area_contorno:.2f} pixels²")
    print(f"Circularidade do Contorno Real: {circularidade_real:.4f}")

    cv2_imshow(resultado)

"""Funcionou: (kernel 9,9/5 iterações)
- L50.V1000.P20.tif
"""